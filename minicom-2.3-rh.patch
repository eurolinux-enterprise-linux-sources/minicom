diff --git a/src/main.c b/src/main.c
index 6be7cfe..b160ce5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -87,7 +87,7 @@ void leave(const char *s)
   }
   set_privs();
   if (lockfile[0])
-    unlink(lockfile);
+    ttyunlock(lockfile);
   if (P_CALLIN[0])
     fastsystem(P_CALLIN, NULL, NULL, NULL);
   if (real_uid)
@@ -161,10 +161,14 @@ void term_socket_close(void)
 int open_term(int doinit, int show_win_on_error)
 {
   struct stat stt;
+#ifdef NOTNOW
   char buf[128];
-  int fd, n = 0;
+  int fd;
   int pid;
   int mask;
+#endif
+  int rc;
+  int n = 0;
 #ifdef HAVE_ERRNO_H
   int s_errno;
 #endif
@@ -172,6 +176,8 @@ int open_term(int doinit, int show_win_on_error)
   /* Upgrade our status. */
   set_privs();
 
+#ifdef NOTNOW
+
   /* First see if the lock file directory is present. */
   if (P_LOCK[0] && stat(P_LOCK, &stt) == 0) {
 
@@ -243,6 +249,44 @@ int open_term(int doinit, int show_win_on_error)
       close(fd);
   }
 
+#else
+  lockfile[0] = 0;
+  if (doinit >= 0) {
+#ifdef USE_SOCKET
+    if (strncmp(dial_tty, SOCKET_PREFIX, strlen(SOCKET_PREFIX)) == 0) {
+      if (stat(dial_tty+strlen(SOCKET_PREFIX), &stt) == 0 &&
+         S_ISSOCK(stt.st_mode)) {
+        rc = 0;
+      } else {
+        rc = 1;
+        fprintf(stderr, _("File %s is not a socket.\n"),
+                dial_tty+strlen(SOCKET_PREFIX));
+      }
+    } else {
+#endif
+      rc = ttylock(dial_tty);
+      if (rc < 0) {
+        if (access(dial_tty, W_OK) == -1)
+          fprintf(stderr, _("Device %s access failed: %s.\n"),
+                  dial_tty, strerror(errno));
+        else
+          fprintf(stderr, _("Device %s lock failed: %s.\n"),
+                  dial_tty, strerror(-rc));
+      } else if (rc > 0) {
+        fprintf(stderr, _("Device %s is locked.\n"), dial_tty);
+      }
+#ifdef USE_SOCKET
+    }
+#endif
+    if (rc == 0) {
+      snprintf(lockfile, sizeof(lockfile), "%s", dial_tty);
+    } else {
+      if (stdwin) mc_wclose(stdwin, 1);
+      return(-1);
+    }
+  }
+#endif
+
   /* Run a special program to disable callin if needed. */
     if (doinit > 0 && P_CALLOUT[0]) {
       if (fastsystem(P_CALLOUT, NULL, NULL, NULL) < 0) {
@@ -250,7 +294,7 @@ int open_term(int doinit, int show_win_on_error)
           mc_wclose(stdwin, 1);
         fprintf(stderr, _("Could not setup for dial out.\n"));
         if (lockfile[0])
-          unlink(lockfile);
+          ttyunlock(lockfile);
         drop_privs();
         return -1;
       }
@@ -262,7 +306,6 @@ int open_term(int doinit, int show_win_on_error)
     signal(SIGALRM, get_alrm);
     alarm(4);
 #ifdef USE_SOCKET
-#define SOCKET_PREFIX "unix#"
     portfd_is_socket = portfd_is_connected = 0;
     if (strncmp(dial_tty, SOCKET_PREFIX, strlen(SOCKET_PREFIX)) == 0) {
       portfd_is_socket = 1;
@@ -310,12 +353,12 @@ int open_term(int doinit, int show_win_on_error)
       fprintf(stderr, _("minicom: cannot open %s. Sorry.\n"), dial_tty);
 #endif
       if (lockfile[0])
-        unlink(lockfile);
+        ttyunlock(lockfile);
       drop_privs();
       return -1;
     }
     if (lockfile[0])
-      unlink(lockfile);
+      ttyunlock(lockfile);
     if (show_win_on_error)
       werror(_("Cannot open %s!"), dial_tty);
     drop_privs();
diff --git a/src/minicom.c b/src/minicom.c
index 3651f72..5571aff 100644
--- a/src/minicom.c
+++ b/src/minicom.c
@@ -1548,8 +1548,7 @@ dirty_goto:
   mc_wclose(stdwin, 1);
   set_privs();
   keyboard(KUNINSTALL, 0);
-  if (lockfile[0])
-    unlink(lockfile);
+  lockfile_remove();
   close(portfd);
   /* Please - if your system doesn't have uid_t and/or gid_t, define 'em
    * conditionally in "port.h".
diff --git a/src/minicom.h b/src/minicom.h
index b34a33c..7d47753 100644
--- a/src/minicom.h
+++ b/src/minicom.h
@@ -33,11 +33,16 @@
 #include "vt100.h"
 #include "libport.h"
 
+#include <limits.h>
 #include <time.h>
 
+#include <baudboy.h>
+
 #ifdef USE_SOCKET
 #include <sys/socket.h>
 #include <sys/un.h>
+
+#define SOCKET_PREFIX "unix#"
 #endif
 
 /*
@@ -84,7 +89,7 @@ EXTERN int tempst;	/* Status line is temporary */
 EXTERN int escape;	/* Escape code. */
 EXTERN int disable_online_time; /* disable online time display */
 
-EXTERN char lockfile[128]; /* UUCP lock file of terminal */
+EXTERN char lockfile[PATH_MAX]; /* UUCP lock file of terminal */
 EXTERN char homedir[256];  /* Home directory of user */
 EXTERN char logfname[PARS_VAL_LEN]; /* Name of the logfile */
 EXTERN char username[16];  /* Who is using minicom? */
@@ -309,10 +314,8 @@ extern int io_pending, pendingkeys;
 /* Prototypes from file: config.c */
 void domacros(void);
 
-
-
-
-
+void lockfile_create(void);
+void lockfile_remove(void);
 
 /* We want the ANSI offsetof macro to do some dirty stuff. */
 #ifndef offsetof
diff --git a/src/updown.c b/src/updown.c
index 4eaf5ec..ef411b7 100644
--- a/src/updown.c
+++ b/src/updown.c
@@ -375,6 +375,42 @@ void updown(int what, int nr)
     mc_wclose(win, 1);
 }
 
+void lockfile_remove(void)
+{
+  if (lockfile[0] && strncmp(dial_tty, SOCKET_PREFIX, strlen(SOCKET_PREFIX)) != 0)
+    ttyunlock(lockfile);
+}
+
+void lockfile_create(void)
+{
+  int rc;
+#ifdef NOTNOW
+  int fd, n;
+  char buf[81];
+
+  if (!lockfile[0])
+    return;
+
+  n = umask(022);
+  /* Create lockfile compatible with UUCP-1.2 */
+  if ((fd = open(lockfile, O_WRONLY | O_CREAT | O_EXCL, 0666)) < 0) {
+    werror(_("Cannot create lockfile!"));
+  } else {
+    snprintf(buf, sizeof(buf),  "%05d minicom %.20s\n", (int)getpid(), username);
+    write(fd, buf, strlen(buf));
+    close(fd);
+  }
+  umask(n);
+#else
+  if (strncmp(dial_tty, SOCKET_PREFIX, strlen(SOCKET_PREFIX)) != 0) {
+    rc = ttylock(lockfile);
+    if (rc) {
+      werror(_("Cannot lock device!"));
+    }
+  }
+#endif
+}
+
 /*
  * Run kermit. Used to do this in the main window, but newer
  * versions of kermit are too intelligent and just want a tty
@@ -384,8 +420,10 @@ void kermit(void)
 {
   int status;
   int pid, n;
+#ifdef NOTNOW
   char buf[81];
   int fd;
+#endif
 
   /* Clear screen, set keyboard modes etc. */
   mc_wleave();
@@ -399,7 +437,7 @@ void kermit(void)
       /* Remove lockfile */
       set_privs();
       if (lockfile[0])
-        unlink(lockfile);
+        ttyunlock(lockfile);
       setgid((gid_t)real_gid);
       setuid((uid_t)real_uid);
 
@@ -420,6 +458,7 @@ void kermit(void)
   /* Re-create lockfile */
   if (lockfile[0]) {
     set_privs();
+#ifdef NOTNOW
     n = umask(022);
     /* Create lockfile compatible with UUCP-1.2 */
     if ((fd = open(lockfile, O_WRONLY | O_CREAT | O_EXCL, 0666)) < 0) {
@@ -431,6 +470,9 @@ void kermit(void)
       close(fd);
     }
     umask(n);
+#else
+    ttylock(lockfile);
+#endif
     drop_privs();
   }
   m_flush(portfd);
